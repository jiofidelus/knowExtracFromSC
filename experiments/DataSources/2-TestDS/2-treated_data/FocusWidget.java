package com.google.gwt.user.client.ui ; @SuppressWarnings("deprecation")public abstract class FocusWidget extends Widget implements SourcesClickEvents, HasClickHandlers, HasDoubleClickHandlers, HasFocus, HasEnabled, HasAllDragAndDropHandlers, HasAllFocusHandlers, HasAllGestureHandlers, HasAllKeyHandlers, HasAllMouseHandlers, HasAllTouchHandlers, SourcesMouseEvents { private static final FocusImpl impl = FocusImpl.getFocusImplForWidget() ;  * Gets the FocusImpl instance. *  * @return impl protected static FocusImpl getFocusImpl() { return impl ;  }  * Creates a new focus widget with no element. {@link #setElement(Element)} * must be called before any other methods. protected FocusWidget() { }  * Creates a new focus widget that wraps the specified browser element. *  * @param elem the element to be wrapped protected FocusWidget(Element elem) { setElement(elem) ;  }  public HandlerRegistration addBlurHandler(BlurHandler handler) { return addDomHandler(handler, BlurEvent.getType()) ;  }  public HandlerRegistration addClickHandler(ClickHandler handler) { return addDomHandler(handler, ClickEvent.getType()) ;  }  * @deprecated Use {@link #addClickHandler} instead @Deprecated public void addClickListener(ClickListener listener) { ListenerWrapper.WrappedClickListener.add(this, listener) ;  }  public HandlerRegistration addDoubleClickHandler(DoubleClickHandler handler) { return addDomHandler(handler, DoubleClickEvent.getType()) ;  }  public HandlerRegistration addDragEndHandler(DragEndHandler handler) { return addBitlessDomHandler(handler, DragEndEvent.getType()) ;  }  public HandlerRegistration addDragEnterHandler(DragEnterHandler handler) { return addBitlessDomHandler(handler, DragEnterEvent.getType()) ;  }  public HandlerRegistration addDragHandler(DragHandler handler) { return addBitlessDomHandler(handler, DragEvent.getType()) ;  }  public HandlerRegistration addDragLeaveHandler(DragLeaveHandler handler) { return addBitlessDomHandler(handler, DragLeaveEvent.getType()) ;  }  public HandlerRegistration addDragOverHandler(DragOverHandler handler) { return addBitlessDomHandler(handler, DragOverEvent.getType()) ;  }  public HandlerRegistration addDragStartHandler(DragStartHandler handler) { return addBitlessDomHandler(handler, DragStartEvent.getType()) ;  }  public HandlerRegistration addDropHandler(DropHandler handler) { return addBitlessDomHandler(handler, DropEvent.getType()) ;  }  public HandlerRegistration addFocusHandler(FocusHandler handler) { return addDomHandler(handler, FocusEvent.getType()) ;  }  * @deprecated Use {@link #addFocusHandler} instead @Deprecated public void addFocusListener(FocusListener listener) { ListenerWrapper.WrappedFocusListener.add(this, listener) ;  }  public HandlerRegistration addGestureChangeHandler(GestureChangeHandler handler) { return addDomHandler(handler, GestureChangeEvent.getType()) ;  }  public HandlerRegistration addGestureEndHandler(GestureEndHandler handler) { return addDomHandler(handler, GestureEndEvent.getType()) ;  }  public HandlerRegistration addGestureStartHandler(GestureStartHandler handler) { return addDomHandler(handler, GestureStartEvent.getType()) ;  }  * @deprecated Use {@link #addKeyDownHandler}, {@link * #addKeyUpHandler} and {@link #addKeyPressHandler} instead @Deprecated public void addKeyboardListener(KeyboardListener listener) { ListenerWrapper.WrappedKeyboardListener.add(this, listener) ;  }  public HandlerRegistration addKeyDownHandler(KeyDownHandler handler) { return addDomHandler(handler, KeyDownEvent.getType()) ;  }  public HandlerRegistration addKeyPressHandler(KeyPressHandler handler) { return addDomHandler(handler, KeyPressEvent.getType()) ;  }  public HandlerRegistration addKeyUpHandler(KeyUpHandler handler) { return addDomHandler(handler, KeyUpEvent.getType()) ;  }  public HandlerRegistration addMouseDownHandler(MouseDownHandler handler) { return addDomHandler(handler, MouseDownEvent.getType()) ;  }  * @deprecated Use {@link #addMouseOverHandler} {@link * #addMouseMoveHandler}, {@link #addMouseDownHandler}, {@link * #addMouseUpHandler} and {@link #addMouseOutHandler} instead @Deprecated public void addMouseListener(MouseListener listener) { ListenerWrapper.WrappedMouseListener.add(this, listener) ;  }  public HandlerRegistration addMouseMoveHandler(MouseMoveHandler handler) { return addDomHandler(handler, MouseMoveEvent.getType()) ;  }  public HandlerRegistration addMouseOutHandler(MouseOutHandler handler) { return addDomHandler(handler, MouseOutEvent.getType()) ;  }  public HandlerRegistration addMouseOverHandler(MouseOverHandler handler) { return addDomHandler(handler, MouseOverEvent.getType()) ;  }  public HandlerRegistration addMouseUpHandler(MouseUpHandler handler) { return addDomHandler(handler, MouseUpEvent.getType()) ;  }  public HandlerRegistration addMouseWheelHandler(MouseWheelHandler handler) { return addDomHandler(handler, MouseWheelEvent.getType()) ;  }  * @deprecated Use {@link #addMouseWheelHandler} instead @Deprecated public void addMouseWheelListener(MouseWheelListener listener) { ListenerWrapper.WrappedMouseWheelListener.add(this, listener) ;  }  public HandlerRegistration addTouchCancelHandler(TouchCancelHandler handler) { return addDomHandler(handler, TouchCancelEvent.getType()) ;  }  public HandlerRegistration addTouchEndHandler(TouchEndHandler handler) { return addDomHandler(handler, TouchEndEvent.getType()) ;  }  public HandlerRegistration addTouchMoveHandler(TouchMoveHandler handler) { return addDomHandler(handler, TouchMoveEvent.getType()) ;  }  public HandlerRegistration addTouchStartHandler(TouchStartHandler handler) { return addDomHandler(handler, TouchStartEvent.getType()) ;  }  * Gets the tab index. *  * @return the tab index public int getTabIndex() { return impl.getTabIndex(getElement()) ;  }  * Gets whether this widget is enabled. *  * @return <code>true</code> if the widget is enabled public boolean isEnabled() { return !DOM.getElementPropertyBoolean(getElement(), "disabled") ;  }  * @deprecated Use the {@link HandlerRegistration#removeHandler} method on  * the object returned by {@link #addClickHandler} instead @Deprecated public void removeClickListener(ClickListener listener) { ListenerWrapper.WrappedClickListener.remove(this, listener) ;  }  * @deprecated Use the {@link HandlerRegistration#removeHandler} method on  * the object returned by {@link #addFocusHandler} instead @Deprecated public void removeFocusListener(FocusListener listener) { ListenerWrapper.WrappedFocusListener.remove(this, listener) ;  }  * @deprecated Use the {@link HandlerRegistration#removeHandler} * method on the object returned by an add*Handler method instead @Deprecated public void removeKeyboardListener(KeyboardListener listener) { ListenerWrapper.WrappedKeyboardListener.remove(this, listener) ;  }  * @deprecated Use the {@link HandlerRegistration#removeHandler} * method on the object returned by an add*Handler method instead @Deprecated public void removeMouseListener(MouseListener listener) { ListenerWrapper.WrappedMouseListener.remove(this, listener) ;  }  * @deprecated Use the {@link HandlerRegistration#removeHandler} * method on the object returned by {@link #addMouseWheelHandler} instead @Deprecated public void removeMouseWheelListener(MouseWheelListener listener) { ListenerWrapper.WrappedMouseWheelListener.remove(this, listener) ;  }  public void setAccessKey(char key) { DOM.setElementProperty(getElement(), "accessKey", "" + key) ;  }  * Sets whether this widget is enabled. *  * @param enabled <code>true</code> to enable the widget, <code>false</code> * to disable it public void setEnabled(boolean enabled) {  String tagName = getElement().getTagName().toLowerCase() ;  if(tagName.equals("input") || tagName.equals("textarea")){ if(enabled){ DOM.removeElementAttribute(getElement(), "readOnly") ;  } else{ DOM.setElementProperty(getElement(), "readOnly", "readonly") ;  }  } else{ DOM.setElementPropertyBoolean(getElement(), "disabled", !enabled) ;  }  }  public void setFocus(boolean focused) { if (focused) { impl.focus(getElement()) ;  }  else { impl.blur(getElement()) ;  }  }  public void setTabIndex(int index) { impl.setTabIndex(getElement(), index) ;  }  @Override protected void onAttach() { super.onAttach() ;  // Accessibility: setting tab index to be 0 by default, ensuring element // appears in tab sequence. We must ensure that the element doesn't already // have a tabIndex set. This is not a problem for normal widgets, but when // a widget is used to wrap an existing static element, it can already have // a tabIndex. int tabIndex = getTabIndex() ;  if (-1 == tabIndex) { setTabIndex(0) ;  }  } }